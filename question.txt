// Async await / promises
// Task A => task B, C => task D
// await A => await Promise.all[B, C] => task D
components
helpers
pages
routers
states
styles

JAVASCRIPT
1/ Phân biệt let, var, const
- Đều dung để khai báo biến
    - Let
        - Các biến được khai báo là let sẽ có scope là block scope
        - Cho phép chúng ta cập nhật lại giá trị của biến chứ không cho phép tái khái bái lại biến đó
            - let greeting = "say Hi";
            - let greeting = "say Hello instead"; // error: Identifier 'greeting' has already been declared
        - Đối với các block khác nhau thì việc tái khai báo sẽ không gây ra lỗi
    - Var
        - Các biến được khai báo là var thì sẽ có scope là function-scoped  hoặc global-scoped (See ex2)
            Nếu có code block bên trong một function thì vả trở thành function-level variable:
            function sayHi() {
              if (true) {
                var phrase = "Hello";
              }
              alert(phrase); // works
            }
            sayHi();
            alert(phrase); // ReferenceError: phrase is not defined

        - Cho phép khai báo lại biến đó
        - Các biến var có thể được khai báo dưới việc sử dụng chúng (Người ta gọi đó là hoisting, 
          bởi vi các biến được khai báo là vả được raised lên đầu của function)
            - Declarations thì được hoisted, nhưng assignment thì không
    - Const
        - Để khai báo 1 hắng số
        - Không thể cập nhật giá trị

2/ Con trỏ this
- Giá trị của this là một object trước dấu .
- Khi gọi mà không có đối tượng thì thís == undefined (See ex3)
  function sayHi() {
    alert(this);
  }
  sayHi(); // undefined

- Arrow function không có this
    - Nếu chúng ta tham chiếu thí trong arrow function, nó sẽ được lấy từ outer function

3/ Functions
- Function declaration: function say(name) {}
- Function expression: const say = function say() {}
- Lexical environment bao gồm 2 phần: Environment Record and outer lexical environment
- Closure
    - Tất cả function trong javascript đều là closure
    - Tất cả function đều ghi nhớ các outer variables của nó và có thể truy cập nó.
    - Tất cả cái function có thuộc tính ẩn là Environment

4/ Phân biệt pure function và impure function
- Pure function phải thoả mãn 2 điều kiện
    - Các input giống nhau luôn trả ra output giống nhau
    - Không có side effects:
        - Modifying an argument
        - Modifying a global variable
        - Making HTTP request

5/ Data Type
  - Primitive, Null , Undefined, boolean, Number, string, symbol
  - Reference: Kế thừa từ object 
    - Date, Set, Map, Function, Array
    - Map: là 1 collection có key và value, khác với object, Map cho phép key là any type
      - method: (new Map(), map.set(key, value), map.get(key), 
        map.has(key), map.delete(key), map.clear(), map.size)
      - iteration: 
        vd: let vegetable of recipeMap.keys(), let amount of recipeMap.values(), let entry of recipeMap

    - Set: là tập hợp value (không có key), trong đó mỗi giá trị chỉ xuất hiện 1 lần
      - method: new Set(iterable), set.add(value), set.delete(value), 
        set.has(value), set.clear(), set.size()

6/ Microtasks: promises
   Macrotasks: setTimeOut
    + Microtasks chạy trước Macrotasks

7/ Generator function: 
- Function*
  Khi nó đc gọi, nó không thục thi code, thay vào đó nó return 1 object, để quản lý execution
  method chình là main

REACT
1/ HOC
- A Hoc là 1 function mà nó nhận vào 1 component và returns 1 component mới
- Sử dụng HOC cho Cross-cutting concerns(Những logic phụ cần  được thực hiện khi logic chính được gọi)

2/ Error Boundaries
- Là 1 react component mà nó catch javascript error trong cây thành phần con của nó, 
  log error đó và display 1 fallbackUI thay vì component tree sẽ bị crashed
- Error Boundaries catch error trong quá trình render, in lifecycle and in constructor
      static getDerivedStateFromError() or componentDidCatch()

3/ Hook là gì ?
- Là những hàm cho phép bạn “kết nối” React state and lifecycle vào các function component
- Lợi ích: 
    - Code ngắn hơn
    - Hoàn toàn tự nguyện, 100% tương thích ngược

4/ Function component và class component
- Khác nhau lớn nhất giữa function component và class component là
    - Function component capture các giá trị đã render

5/ UseRef
- Là một hook dùng để access đến DOM element hoặc 1 instance của component

6/ Render Props
- Share code giữa các component sử dụng 1 prop có value là một function

7/ Server side rendering và client side rendering
- Server side rendering
  + Nội dung HTML được server xử lý và trả về cho browser, tuy nhiên lúc này web
  mới chỉ thấy nội dung, chưa thể tương tác được. Trình duyệt vẫn tiếp tục tải JS về

- Client side rendering
  + Trong csr, thì gánh nặng biên dịch nội dung và tạo html được chuyển sang client

- Compare ssr vs csr
  - Web page load time
    - First page load time: 
      + CSR: browser load html, css, và js một lần sau đó compile HTML có thể sử dụng trên trình duyệt
      + SSR: SSR mất ít thời gian hơn bình thường khi lần đầu tiên tải
    - Second and further page load time: thời gian tải trang lần 2 là thời gian chuyển từ page này 
      sang page khác
      + CSR: Do tất cả js được tải lên trước cho client, thời gian tải sẽ ít hơn 
      + SCR: Chu kỳ tải trang đầu tiên được lặp lại. Do đó thời gian tải sẽ mất thời gian hơn csr

8/ Phân biệt angular với reactjs
  Có nhiều yếu tố để so sánh lắm: m nói theo kinh nghiệm thôi. VD: về angular tiện cho mới học, 
  vì framework hoàn chỉnh, chỉ đọc document & dùng tính năng. 
  React thì học nhiều thứ, vì react thì flexible, cho tích hợp nhiều thứ- thư viện bên thứ 3.

  Ưu điểm react: flexible, key là react native vì làm mobile, dễ dàng chuyển sang mobile nhanh. RN cross platform phổ biến.
  Nhược điểm: khó vs người mới học

  Angular: tích hợp sẵn TS. React thuận JS, vẫn có template để xài TS

  Tốc độ render thì thao tác DOM vs HTML => đọc benchmarch trên mạng thì angular tốt hơn.
  Về lưu trữ bộ nhớ thì React tốt hơn
  => Tốc độ 2 thằng same same

  Cộng đồng : react nhiều hơn, có react native, 
  k bị breaking change như angular ( angularJS, Angular 2,4,7,8, ...) phải học lại

  Cả 2 điều có đẩy đủ: binding, quản lý bộ nhớ, routing seem nhau

  Vì xu hướng là mobile first => react native phổ biến hơn angular có ionic. 
  Cân nhắc tuỳ theo dự án cần mobile app hay ko ? tối ưu thời gian hay ko

CHALLENGE
1/ Cho một mảng, khi bỏ 1 phần tử trong mảng thì mảng vẫn đảm bảo tăng dần
Ex: arr = [1,5,4,7,8]

2/ Viêt hàm compare tuổi
A {age: 18, name: 'A'} . B {name: 'A', age: 18}

3/ Arr = [2, 3, 4, 5]
  Cho cái mảng. 
  - Tính sô lần tăng cho đến khi giá trị mảng bằng nhau
  - Mỗi lần tăng lên 1 đơn vị phải giữ lại 1 giá trị không tăng
  VD:
  Arr[3]: [3, 4, 5, 5] result = 1
  Arr[2]: [4, 5, 5, 6] result = 2
  Arr[3]: [5, 6, 6, 6] result = 3
  Arr[1]: [6, 6, 7, 7] result = 4
  Arr[3]: [7, 7, 8, 7] result = 5
  Arr[2]: [8, 8, 8, 8] result = 6
  Result 6

4/ arr = [2, 3, 4, 8, 10, 5, 6];
- Ví dụ mỗi phần tử là doanh thu từng tháng theo thứ tự (tháng 1 => tháng 12), tính chệch lệch doanh thu lơn nhất giữa 2 tháng
EX: arr = [2, 3, 4, 8, 10, 5, 6]; => result = 8 - 4 = 4;
Ex: arr = [5, 4, 4, 2, 2]; => result = -1; (Không có tháng nào)


